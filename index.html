<!-- Build webpage: http://web.engr.oregonstate.edu/~stumbaup/Portfolio/ -->
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF=8">
  <title>Patrick Stumbaugh - Portfolio</title>
  <link rel="stylesheet" href="./portfolioStyles.css" type="text/css">
</head>

<body class="body">

  <!-- Top of page, name -->

  <div class="headerText">Patrick Stumbaugh</div>
  <br><br><br><br><br><br><br><br>
  <!-- Sub intro -->
  <div class="about">
    <p>Hello world!</p>
    <p>I am a jr. software developer and website designer</p>
  </div>

  <!-- header image-->
  <div class="headerImageContainer">
    <img class="headerImage" src="./images/greysideheaderImageEdited2.jpg">
  </div>

  <br>

  <!--- test scroll up
    <div class="test2">
      <img id="myImg" src="./images/portfoliopic.jpeg" width="304" height="228">
    </div> 
 -->


  <!-- Code introduction -->
  <div class="codeBackground"> </div>

  <div class="codeContainer">
    <div id="code">
      <div id="console">
        Patrick.self<br>
        <span class="answer">&nbsp;&nbsp;&gt; "Patrick Stumbaugh"<br><br></span>
        Patrick.education<br>
        <span class="answer">
          &nbsp;&nbsp;&gt; Current:<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; college: "Oregon State University"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; degree: "Computer Science"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; expected_graduation: Fall 2021 / Winter 2022<br>
          <br>&nbsp;&nbsp;&gt; Previous:<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; college: "Gonzaga University"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; degree: "Business Administration"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; concentration: "Marketing"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor: "Broadcast and Electronic Media Studies"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; minor: "Comprehensive Leadership"<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; graduated: 2010<br>
          <br></span>
        Patrick.resume<br>
        <span class="answer">&nbsp;&nbsp;&gt; "<a target="_blank"
            href="./Resume, Patrick Stumbaugh.pdf">resume.pdf</a>"<br><br></span>
        Patrick.email<br>
        <span class="answer">&nbsp;&nbsp;&gt; "<a target="_blank"
            href="mailto:stumbaugh.patrick@gmail.com">stumbaugh.patrick@gmail.com</a>"<br><br></span>
        Patrick.phone<br>
        <span class="answer">&nbsp;&nbsp;&gt; "<a href="tel:6508683189">(650) 868-3189</a>"<br><br></span>
      </div>
    </div>
  </div>



  <!-- Picture and links-->
  <div class="mainPicture">
    <img id="myImage" src="./images/portpic2crop.jpeg" alt="Pat and his dogs Harper and Waldo">
    <br>
    <a target="_blank" href="https://github.com/pstumbaugh/Portfolio">
      <img id="buttonsImageCode" src="./images/githublogo2.png" alt="Github"></a>
    &nbsp;&nbsp;&nbsp;
    <a target="_blank" href="https://www.linkedin.com/in/patrick-stumbaugh-7625662a/">
      <img id="buttonsImageCode2" src="./images/linkedinlogo2.png" alt="LinkedIn"></a>
  </div>

  <div class="drippingYellowContainer">
    <img class="drippingYellow" src="./images/rightsideDrippingYellowEditedSIDES copy.png">
  </div>

  <br><br><br><br><br><br>


  <!-- Work Experience Examples -->


  <table class="resumeTableContainer">
    <th class="revealClass" id="revealWorkExperience1">
      <div class="headerTextBody">Current Employment</div>
      <br>

      <table class="resumeTable">
        <thread>
          <tr>
            <th class="tableTitle">Ignite (Production) Director</th>
            <th class="tableTitle2">KATU-TV</th>
          </tr>
          <tr>
            <th> </th>
            <th> Feb. 2015 - current</th>
          </tr>
          <tr>
            <th>Lead director - 5pm newscast and Afternoon Live talk show </th>
          </tr>
          <tr>
            <th>Code show elements cohesive with Ignite software</th>
          </tr>
          <tr>
            <th>Manage creative direction and production crews on special projects</th>
          </tr>
          <tr>
            <th>Develop and integrate graphic design elements</th>
          </tr>
          <tr>
            <th>End-to-end video broadcast control room management</th>
          </tr>
        </thread>
      </table>
    </th>


    <th class="revealClass" id="revealWorkExperience2">
      <div class="headerTextBody">Previous Employment</div>
      <br>

      <table class="resumeTable">
        <thread>
          <tr>
            <th class="tableTitle">Senior Ross OverDrive Director</th>
            <th class="tableTitle2">WVLT-TV</th>
          </tr>
          <tr>
            <th> </th>
            <th> Feb. 2012 - Feb. 2015</th>
          </tr>
          <tr>
            <th>Manage station&apos;s video production operations via Ross OverDrive</th>
          </tr>
          <tr>
            <th>Assimilate Vizrt graphics software with automation control</th>
          </tr>
          <tr>
            <th>Develop and advance new automation elements</th>
          </tr>
          <tr>
            <th>Principal nightside graphic designer</th>
          </tr>
          <tr>
            <th></th>
          </tr>
          <tr>
            <th></th>
          </tr>
          <tr>
            <th></th>
          </tr>
          <tr>
            <th></th>
          </tr>

        </thread>
      </table>
    </th>
  </table>

  <br>

  <a download target="_blank" href="./Resume, Patrick Stumbaugh.pdf" id="fullResume">Full Resume</a>

  <br><br><br>


  <!-- Coding Examples Title-->
  <div class="codeExamplesTitleContainer">
    <h4 class="codeTextBody">Coding Examples</h4>
  </div>
  <br><br><br><br>

  <!--- Code Examples -->
  <div class="codeExamplesContainer">

    <div class="codeExamplesClassReveal" id="hikersGuideReveal">
      <!-- Portland Hiker's Guide website-->
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
            <pre class="codeExampleInnerBox">
&lt!DOCTYPE html>
&lthtml>

  &lthead>
    &ltmeta charset="UTF=8">
    &lttitle>Portland Hiker's Guide&lt/title>
    &ltlink rel="stylesheet" href="styles.css" type="text/css">

    &ltlink rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    &ltscript src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js">&lt/script>
    &ltscript src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js">&lt/script>

  &lt/head>

  &ltbody class="body">

    &ltul class="menuBarUL">
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/index">Home&lt/a>&lt/li>
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/waterfalls">Waterfall Hikes&lt/a>&lt/li>
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/shortHikes">Short Hikes&lt/a>&lt/li>
      &ltli class="menuBarLi">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/dogFriendlyHikes">Dog-Friendly Hikes&lt/a>&lt/li>
      &ltli class="menuBarLiRight">&lta class="menuBarItemsHome" href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/aboutMe">About&lt/a>&lt/li>
    &lt/ul>

    &ltdiv class="headerHOMEbackground">
      &ltdiv class="headerHOMEcontent">
        &ltbr>
        &lth1 style="font-size:50px">PORTLAND HIKER'S GUIDE&lt/h1>
        &ltspan class="headerHOMEcontentSub">Your guide to &ltbr> hiking in the NorthWest &lt/span>
        &ltbr>&ltbr>
        &ltspan class="headerHOMEcontentSub2">Get out there and explore! &lt/span>
      &lt/div>
    &lt/div>

    &ltbr>

    &lttable class="homeButtons">
      &ltthread>
        &lttr>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/waterfalls">
              &ltimg class="buttonsImage" src="./images/home_waterfalls.jpg" alt="Waterfall hikes">
            &lt/a>
          &lt/th>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/shortHikes">
              &ltimg class="buttonsImage" src="./images/home_shorthikes.jpg" alt="Short hikes">
            &lt/a>
          &lt/th>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/dogFriendlyHikes">
              &ltimg class="buttonsImage" src="./images/home_dogfriendly.jpg" alt="Dog-friendly hikes">
            &lt/a>
          &lt/th>
          &ltth class="buttonsPadding">
            &lta href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/aboutMe">
              &ltimg class="buttonsImage" src="./images/home_aboutme.jpg" alt="About me">
            &lt/a>
          &lt/th>
        &lt/tr>

        &lttr>
          &ltth class="homeButtonsText">
            &lth4>
              Waterfalls
            &lt/h4>
            &ltbr>
          &lt/th>
          &ltth class="homeButtonsText">
            &lth4>
              Short Hikes
            &lt/h4>
            &ltbr>
          &lt/th>
          &ltth class="homeButtonsText">
            &lth4>
              Dog-friendly
            &lt/h4>
            &ltbr>
          &lt/th>
          &ltth class="homeButtonsText">
            &lth4>
              About Me
            &lt/h4>
            &ltbr>
          &lt/th>

        &lt/tr>

      &lt/thread>
    &lt/table>

    &ltbr>

    &lttable class="carouselTable">
      &ltthread>
        &lttr>
          &ltth>
            &lt!--- adapted from https://www.w3schools.com/bootstrap/bootstrap_carousel.asp --->
            &ltdiv class="slideshow-container">
              &ltdiv id="myCarousel" class="carousel slide" data-ride="carousel">
                &lt!-- Indicators -->
                &ltol class="carousel-indicators">
                  &ltli data-target="#myCarousel" data-slide-to="0" class="active">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="1">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="2">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="3">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="4">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="5">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="6">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="7">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="8">&lt/li>
                  &ltli data-target="#myCarousel" data-slide-to="9">&lt/li>
                &lt/ol>

                &lt!-- Wrapper for slides -->
                &ltdiv class="carousel-inner">
                  &ltdiv class="item active">
                    &ltimg src="./images/carousel/IMG_0325.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_0475.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_0511.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_0769.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_1760.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_1794.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_2196.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_2212.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_9666.jpeg">
                  &lt/div>

                  &ltdiv class="item">
                    &ltimg src="./images/carousel/IMG_9685.jpeg">
                  &lt/div>
                &lt/div>

                &lt!-- Left and right controls -->
                &lta class="left carousel-control" href="#myCarousel" data-slide="prev">
                  &ltspan class="glyphicon glyphicon-chevron-left">&lt/span>
                  &ltspan class="sr-only">Previous&lt/span>
                &lt/a>
                &lta class="right carousel-control" href="#myCarousel" data-slide="next">
                  &ltspan class="glyphicon glyphicon-chevron-right">&lt/span>
                  &ltspan class="sr-only">Next&lt/span>
                &lt/a>
              &lt/div>
            &lt/div>
          &lt/th>
          &ltth class="buttonsPadding">
            &lth4 class="carouselRightText">
              This site is your resource for hiking in and around the Portland area. Think of it as a curated list of my favorite hikes.
              &ltbr>&ltbr>
              Browse and explore some of the featured hikes. You'll find trail highlights and photos from my favorite viewpoints. You'll also find current weather information if you're planning to get out today!
              &ltbr>&ltbr>
              Now go out there and explore what our extraordinary Pacific Northwest has to offer.
            &lt/h4>
          &lt/th>
        &lt/tr>
      &lt/thread>
    &lt/table>

    &ltbr>
    &ltbr>
    &lt!-- Footer image borred from traveloregon.com -->
    &ltdiv id="footberBottomTreesHome">&lt/div>

    &ltscript src="home.js">&lt/script>
  &lt/body>

&lt/html>
           
    </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">"Portland Hiker's Guide" website</p>
            <img class="codeExampleIcon" src="./images/html5Icon.jpeg">
            <img class="codeExampleIcon" src="./images/CSSIcon.jpeg">
            <img class="codeExampleIcon" src="./images/javascriptIcon.jpeg">
            <br><br>
            <span class="codeTableInnerText">This is a website designed to inspire Portland area hikers to check out
              some of my favorite spots, broken into three types: Waterfalls, Dog-Friendly and Short Hikes.<br><br>
              I built this webpage from scratch, designing the layout and creating the content. I coded all HTML, CSS
              and Javascript. There is also a version built using Node.js and some of the Node modules, however those
              are hosted on a private network, unavailable to the public.</span><br><br>
            <span class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="http://web.engr.oregonstate.edu/~stumbaup/PortlandHikersGuide/">Live Website</a></span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/Portfolio/tree/main/Web%20Design/PortlandHikersGuide">Full Code</a>
            </p>
          </td>
        </tr>
      </table>
    </div>

    <br>

    <!-- Art Gallery Database Website -->
    <div class="codeExamplesClassReveal" id="artGalleryReveal">
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
                <pre class="codeExampleInnerBox">
//Art Gallery database server code (art.js):

var express = require('express');
const bodyParser = require('body-parser');
var mysql = require('./dbcon.js');

//port to use (8875 - Testing // 8877 - Live website)
var port = 8877;

var app = express();
var handlebars = require('express-handlebars').create({
  defaultLayout: 'main'
});

app.engine('handlebars', handlebars.engine);
app.set('view engine', 'handlebars');
app.set('port', port);

app.use(express.static('public'));
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());


//-------------------HOME SECTION--------------------------------------------------------------//

//home page setup
//Get and display (send back) all the items from the SQL table
app.get('/', function (req, res, next) {
  var context = {};
  res.render('home', context);
});

//home page setup
//Get and display (send back) all the items from the SQL table
app.get('/index', function (req, res, next) {
  var context = {};
  res.render('home', context);
});





//-------------------ARTISTS SECTION--------------------------------------------------------------//

//DELETE ARTIST
//Deletes an artist from the table using the ID
app.delete('/deleteArtist/:id', function (req, res) {
  var sql = "DELETE FROM Artists WHERE artistID = ?";
  var inserts = [req.params.id];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) { //if error, log it in the console
      console.log(error)
      res.write(JSON.stringify(error));
      res.status(400);
      res.end();
    } else { //if success, return 202 status
      res.status(202).end();
    }
  })
});

//UPDATE ARTISTS PAGE
//page for the artist that the user is wanting to update.
//Gets the artist via the ID, sent back as datalist
app.get('/artistsUpdatePage', function (req, res, next) {
  var context = {};
  mysql.pool.query("SELECT * FROM Artists WHERE artistID=?", [req.query.id], function (err, rows, fields) {
    if (err) { //if error, return error message
      next(err);
      return;
    }

    context.dataList = rows;
    res.render('updateArtists', context);
  })
});

//UPDATING AN ARTIST
//updates an artist given the input from the user
//Will only update if a parameter is given. If it is left blank, the table will not update it and
// will retain whatever information was already in that position
app.get('/safeUpdateArtists', function (req, res, next) {
  var context = {};

  //make sure artist exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Artists WHERE artistID=?", [req.query.artistID], function (err, result) {
    if (err) {
      next(err);
      return;
    }
    //update the artist
    if (result.length == 1) {
      var curVals = result[0];
      mysql.pool.query("UPDATE Artists SET artistFirstName=?, artistLastName=? WHERE artistID=? ",
        [req.query.artistFirstName || curVals.artistFirstName, req.query.artistLastName || curVals.artistLastName, req.query.artistID],
        function (err, result) {
          if (err) {
            next(err);
            return;
          }
          else { //if update successful, display console success message, then render artists page
            context.results = "Updated " + result.changedRows + " rows.";
            res.render('artists', context);
          }
        });
    }
  });
});


//INSERTING AN ARTIST
//Inserts an artist into the Artists table with the given values from user
app.post('/artists', function (req, res) {
  var sql = "INSERT INTO Artists (artistFirstName, artistLastName) VALUES (?, ?)";
  var inserts = [req.body.payloadArtistFirstName, req.body.payloadArtistLastName];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) {
      res.write(JSON.stringify(error));
      res.end();
    }
    else {
      res.redirect('/artists');
    }
  });
});


//MAIN ARTISTS PAGE
//Gets all artists from the data base, returns it as dataList
app.get('/artists', function (req, res) {
  var context = {};
  mysql.pool.query('SELECT * FROM Artists', function (err, rows, fields) {
    if (err) { //if error, retur error message
      console.log("Error getting artists");
      return;
    }

    context.dataList = rows;
    res.render('artists', context);
  })
});





//-------------------CUSTOMERS SECTION--------------------------------------------------------------//

//DELETE CUSTOMER
//Deletes an customer from the table using the ID
app.delete('/deleteCustomer/:id', function (req, res) {
  var sql = "DELETE FROM Customers WHERE customerID = ?";
  var inserts = [req.params.id];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) { //if error, log it in the console
      console.log(error)
      res.write(JSON.stringify(error));
      res.status(400);
      res.end();
    } else { //if success, return 202 status
      res.status(202).end();
    }
  })
});

//UPDATE CUSTOMERS PAGE
//page for the customer that the user is wanting to update.
//Gets the artist via the ID, sent back as datalist
app.get('/customersUpdatePage', function (req, res, next) {
  var context = {};
  mysql.pool.query("SELECT * FROM Customers WHERE customerID=?", [req.query.id], function (err, rows, fields) {
    if (err) { //if error, return error message
      next(err);
      return;
    }

    context.dataList = rows;
    res.render('updateCustomers', context);
  })
});

//UPDATING AN CUSTOMER
//updates a customer given the input from the user
//Will only update if a parameter is given. If it is left blank, the table will not update it and
// will retain whatever information was already in that position
app.get('/safeUpdateCustomers', function (req, res, next) {
  var context = {};

  //make sure customer exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Customers WHERE customerID=?", [req.query.customerID], function (err, result) {
    if (err) {
      next(err);
      return;
    }
    //update the customer
    if (result.length == 1) {
      var curVals = result[0];
      mysql.pool.query("UPDATE Customers SET customerFirstName=?, customerLastName=? WHERE customerID=? ",
        [req.query.customerFirstName || curVals.customerFirstName, req.query.customerLastName || curVals.customerLastName, req.query.customerID],
        function (err, result) {
          if (err) {
            next(err);
            return;
          }
          else { //if update successful, display console success message, then render customers page
            context.results = "Updated " + result.changedRows + " rows.";
            res.render('customers', context);
          }
        });
    }
  });
});


//INSERTING AN CUSTOMER
//Inserts an customer into the Customers table with the given values from user
app.post('/customers', function (req, res) {
  var sql = "INSERT INTO Customers (customerFirstName, customerLastName) VALUES (?, ?)";
  var inserts = [req.body.payloadCustomerFirstName, req.body.payloadCustomerLastName];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) {
      res.write(JSON.stringify(error));
      res.end();
    }
    else {
      res.redirect('/customers');
    }
  });
});


//MAIN CUSTOMERS PAGE
//Gets all customers from the data base, returns it as dataList
app.get('/customers', function (req, res) {
  var context = {};
  mysql.pool.query('SELECT * FROM Customers', function (err, rows, fields) {
    if (err) { //if error, retur error message
      console.log("Error getting customers");
      return;
    }

    context.dataList = rows;
    res.render('customers', context);
  })
});






//-------------------GALLERIES SECTION--------------------------------------------------------------//

//DELETE GALLERY
//Deletes an gallery from the table using the ID
app.delete('/deleteGallery/:id', function (req, res) {
  var sql = "DELETE FROM Galleries WHERE galleryID = ?";
  var inserts = [req.params.id];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) { //if error, log it in the console
      console.log(error)
      res.write(JSON.stringify(error));
      res.status(400);
      res.end();
    } else { //if success, return 202 status
      res.status(202).end();
    }
  })
});

//UPDATE GALLERIES PAGE
//page for the gallery that the user is wanting to update.
//Gets the artist via the ID, sent back as datalist
app.get('/galleriesUpdatePage', function (req, res, next) {
  var context = {};
  mysql.pool.query("SELECT * FROM Galleries WHERE galleryID=?", [req.query.id], function (err, rows, fields) {
    if (err) { //if error, return error message
      next(err);
      return;
    }

    context.dataList = rows;
    res.render('updateGalleries', context);
  })
});

//UPDATING AN GALLERY
//updates a gallery given the input from the user
//Will only update if a parameter is given. If it is left blank, the table will not update it and
// will retain whatever information was already in that position
app.get('/safeUpdateGalleries', function (req, res, next) {
  var context = {};

  //make sure gallery exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Galleries WHERE galleryID=?", [req.query.galleryID], function (err, result) {
    if (err) {
      next(err);
      return;
    }
    //update the gallery
    if (result.length == 1) {
      var curVals = result[0];
      mysql.pool.query("UPDATE Galleries SET galleryName=? WHERE galleryID=? ",
        [req.query.galleryName || curVals.galleryName, req.query.galleryID],
        function (err, result) {
          if (err) {
            next(err);
            return;
          }
          else { //if update successful, display console success message, then render galleries page
            context.results = "Updated " + result.changedRows + " rows.";
            res.render('galleries', context);
          }
        });
    }
  });
});


//INSERTING AN GALLERY
//Inserts an gallery into the Galleries table with the given values from user
app.post('/galleries', function (req, res) {
  var sql = "INSERT INTO Galleries (galleryName) VALUES (?)";
  var inserts = [req.body.payloadGalleryName];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) {
      res.write(JSON.stringify(error));
      res.end();
    }
    else {
      res.redirect('/galleries');
    }
  });
});


//MAIN GALLERIES PAGE
//Gets all galleries from the data base, returns it as dataList
app.get('/galleries', function (req, res) {
  var context = {};
  mysql.pool.query('SELECT * FROM Galleries', function (err, rows, fields) {
    if (err) { //if error, retur error message
      console.log("Error getting galleries");
      return;
    }

    context.dataList = rows;
    res.render('galleries', context);
  })
});






//-------------------PAINTINGS SECTION--------------------------------------------------------------//

//DELETE PAINTING
//Deletes an painting from the table using the ID
app.delete('/deletePainting/:paintingID,:orderID,:galleryID', function (req, res) {
  console.log("test");
  var sql = "DELETE FROM Paintings WHERE paintingID = ?";
  var inserts = [req.params.paintingID];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) { //if error, log it in the console
      console.log(error)
      res.write(JSON.stringify(error));
      res.status(400);
      res.end();
    } else { //if success, return 202 status

      mysql.pool.query("SELECT * FROM `Paintings` WHERE orderID = ? AND galleryID = ?", [req.params.orderID, req.params.galleryID], function (err, nullPaintingsResults) {
        console.log("Number of items in Paintings that also have that order number (after deletion): " + nullPaintingsResults.length);

        if (nullPaintingsResults.length > 1) {
          console.log("More than one painting with the same gallery in the same order -- doing nothing to OrdersToGalleries table");
        }
        else { //If only 1 result, remove that orderID and galleryID relation from the OrdersToGalleries table
          mysql.pool.query("DELETE FROM OrdersToGalleries WHERE orderID = ? AND galleryID = ?", [req.params.orderID, req.params.galleryID], function (err, result) {
            if (err) {
              next(err);
              return;
            }
          });
        }
        res.status(202).end();
      });


    }
  })
});

//UPDATE PAINTINGS PAGE
//page for the painting that the user is wanting to update.
//Gets the painting via the ID, sent back as datalist
app.get('/paintingsUpdatePage', function (req, res, next) {
  var context = {};
  mysql.pool.query("SELECT * FROM Paintings p INNER JOIN Galleries g ON p.galleryID = g.galleryID INNER JOIN Artists a ON p.artistID = a.artistID WHERE paintingID = ?", [req.query.id], function (err, rows, fields) {
    if (err) { //if error, return error message
      next(err);
      return;
    }
    context.dataList = rows;

    mysql.pool.query('SELECT * FROM Galleries ORDER BY galleryID ASC', function (err, galleriesResults, fields) {
      if (err) { //if error, retur error message
        console.log("Error getting galleries");
        return;
      }
      context.gallery = galleriesResults;

      mysql.pool.query('SELECT * FROM Orders ORDER BY orderID ASC', function (err, ordersResults, fields) {
        if (err) { //if error, retur error message
          console.log("Error getting galleries");
          return;
        }
        context.orders = ordersResults;

        mysql.pool.query('SELECT * FROM Artists ORDER BY artistID ASC', function (err, artistsResults, fields) {
          if (err) { //if error, retur error message
            console.log("Error getting galleries");
            return;
          }
          context.artists = artistsResults;

          res.render('updatePaintings', context);
        })
      });
    });
  });
});


//UPDATING AN PAINTING
//updates an painting given the input from the user
//Will only update if a parameter is given. If it is left blank, the table will not update it and
// will retain whatever information was already in that position
app.get('/safeUpdatePaintings', function (req, res, next) {
  var context = {};

  //make sure painting exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Paintings WHERE paintingID=?", [req.query.paintingID], function (err, result) {
    if (err) {
      next(err);
      return;
    }
    //update the painting
    if (result.length == 1) {
      var curVals = result[0];
      mysql.pool.query("UPDATE Paintings SET artistID=?, artType=?, price=?, galleryID=? WHERE paintingID=? ",
        [req.query.artistID || curVals.artistID, req.query.artType || curVals.artType, req.query.price || curVals.price, req.query.galleryID || curVals.galleryID, req.query.paintingID],
        function (err, result) {
          if (err) {
            next(err);
            return;
          }
          else {
            //if there is a new orderID to update, update the orders page too (this will cause order ID's to cascade down to child foreign keys)
            if (req.query.orderID != "") {

              if (req.query.orderID != "NULL") { //if orderID is a not a NULL value
                //update the painting order
                mysql.pool.query("UPDATE Paintings SET orderID=? WHERE paintingID=? ",
                  [req.query.orderID, curVals.paintingID],
                  function (err, result) {
                    if (err) {
                      next(err);
                      return;
                    }
                    else { //if update successful, display console success message, then render paintings page
                      context.results = "Updated " + result.changedRows + " rows.";
                    }
                  });

              } else { //if orderID is a NULL value, set it as null:
                //get the current galleryID and orderID (the orderID before setting it as null)
                var tempGalleryID = req.query.galleryID || curVals.galleryID;
                var tempOrderID = curVals.orderID;

                if (tempOrderID == null) {//do nothing, no order ID to update
                  console.log("ORDER ID already NULL! Not changing the order ID in this query.");

                } else {//do stuff to update order ID to null

                  mysql.pool.query("SELECT * FROM `Paintings` WHERE orderID = ? AND galleryID = ?", [tempOrderID, tempGalleryID], function (err, nullPaintingsResults) {
                    console.log("Number of items in Paintings that already have that order number: " + nullPaintingsResults.length);

                    if (nullPaintingsResults.length > 1) {
                      console.log("More than one painting with the same gallery in the same order -- doing nothing to OrdersToGalleries table");
                    }
                    else { //If only 1 result, remove that orderID and galleryID relation from the OrdersToGalleries table
                      console.log("BEFORE DELETION: current orderID: " + tempOrderID);
                      console.log("BEFORE DELETION: current galleryID: " + tempGalleryID);

                      mysql.pool.query("DELETE FROM OrdersToGalleries WHERE orderID = ? AND galleryID = ?", [tempOrderID, tempGalleryID], function (err, result) {
                        if (err) {
                          next(err);
                          return;
                        }
                      });
                    }

                    //Finally, update the painting to show a NULL orderID:
                    mysql.pool.query("UPDATE Paintings SET orderID=NULL WHERE paintingID=?",
                      [curVals.paintingID],
                      function (err, result) {
                        if (err) {
                          next(err);
                          return;
                        }
                        else { //if update successful, display console success message, then render paintings page
                          context.results = "Updated " + result.changedRows + " rows.";
                        }
                      });
                  }
                  )
                }
              }
            };
          }

          //if there's a new orderID to add, update the table:
          if (req.query.orderID != "NULL" && req.query.orderID != "") {
            //update the OrdersToGalleries table
            mysql.pool.query("INSERT INTO OrdersToGalleries (galleryID, orderID) VALUES (?, ?)",
              [req.query.galleryID || curVals.galleryID, req.query.orderID],
              function (err, result) {
                if (err) {
                  console.log("Duplicate entry in OrdersToGalleries / Not adding");
                }
                else { //if update successful, display console success message, then render paintings page
                  context.results = "Updated " + result.changedRows + " rows.";
                }
              });
          }
          //if there is a new galleryID to update, update the ordersToGalleries page too
          if (req.query.galleryID != "" && req.query.orderID != "NULL") {
            mysql.pool.query("UPDATE OrdersToGalleries SET galleryID=? WHERE orderID=? ",
              [req.query.galleryID, req.query.orderID || curVals.orderID],
              function (err, result) {
                if (err) {
                  next(err);
                  return;
                }
                else { //if update successful, display console success message, then render paintings page
                  context.results = "Updated " + result.changedRows + " rows.";
                }
              });
          }


          res.render('paintings', context);
        })
    };
  });
});


//INSERTING AN PAINTING
//Inserts an painting into the Paintings table with the given values from user
app.post('/paintings', function (req, res) {

  //make sure painting exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Artists WHERE artistID=?", [req.body.payloadArtistID], function (err, checkResults) {
    if (err) {
      next(err);
      return;
    }
    if (checkResults.length == 0) //no artist found, return error
    {
      res.status(409);
      res.sendStatus(409);
    }
    else {
      //make sure gallery exists first (if not, error and exit)
      mysql.pool.query("SELECT * FROM Galleries WHERE galleryID=?", [req.body.payloadGalleryID], function (err, checkResults2) {
        if (err) {
          next(err);
          return;
        }
        if (checkResults2.length == 0) //no artist found, return error
        {
          res.status(400);
          res.sendStatus(400);
        }
        else { //continue with INSERT
          var sql = "INSERT INTO Paintings (artistID, artType, price, galleryID) VALUES (?, ?, ?, ?)";
          var inserts = [req.body.payloadArtistID, req.body.payloadArtType, req.body.payloadPrice, req.body.payloadGalleryID];
          sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
            if (error) {
              res.write(JSON.stringify(error));
              res.end();
            }
            else {
              res.redirect('/paintings');
            }
          });
        }
      })
    };
  });
});

//MAIN PAINTINGS PAGE
//Gets all paintings from the data base, returns it as dataList
app.get('/paintings', function (req, res) {
  var context = {};
  mysql.pool.query('SELECT * FROM Paintings p INNER JOIN Galleries g ON p.galleryID = g.galleryID INNER JOIN Artists a ON p.artistID = a.artistID ORDER BY paintingID', function (err, rows, fields) {
    if (err) { //if error, retur error message
      console.log("Error getting paintings");
      return;
    }
    context.dataList = rows;

    //get the galleryID's (for add new painting section)
    mysql.pool.query('SELECT * FROM Galleries', function (err, resultsGalleries, fields) {
      if (err) { //if error, retur error message
        console.log("Error getting galleries");
        return;
      }
      context.galleries = resultsGalleries;

      //get the artists (for add new painting section)
      mysql.pool.query('SELECT * FROM Artists', function (err, resultsArtists, fields) {
        if (err) { //if error, retur error message
          console.log("Error getting galleries");
          return;
        }
        context.artists = resultsArtists;

        res.render('paintings', context);
      });
    });
  })
});






//-------------------ORDERS SECTION--------------------------------------------------------------//

//DELETE ORDER
//Deletes an order from the table using the ID
app.delete('/deleteOrder/:id', function (req, res) {
  var sql = "DELETE FROM Orders WHERE orderID = ?";
  var inserts = [req.params.id];
  sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
    if (error) { //if error, log it in the console
      console.log(error)
      res.write(JSON.stringify(error));
      res.status(400);
      res.end();
    } else { //if success, return 202 status
      res.status(202).end();
    }
  })
});

//DELETE FROM ORDERS TO GALLERIES TABLE
//Deletes an order from the table using the ID
app.delete('/deleteOTG/:orderID,:galleryID', function (req, res) {
  console.log("-- Deleting from OrdersToGalleries table -- ");
  console.log("ORDER ID: " + req.params.orderID);
  console.log("GALLERY: " + req.params.galleryID);

  //remove from OrdersToGalleries table
  var otgDeleteSql = "DELETE FROM OrdersToGalleries WHERE orderID = ? AND galleryID = ?";
  var inserts = [req.params.orderID, req.params.galleryID];
  otgDeleteSql = mysql.pool.query(otgDeleteSql, inserts, function (error, results, fields) {
    if (error) { //if error, log it in the console
      console.log(error)
      res.write(JSON.stringify(error));
      res.status(400);
      res.end();
    } else {
      console.log("-- Making orderID NULL from Paintings table -- ");
      console.log("ORDER ID: " + req.params.orderID);
      console.log("GALLERY: " + req.params.galleryID);
      //remove orderID from paintings table
      var paintingsDeleteSql = "UPDATE Paintings SET orderID=NULL WHERE orderID=? AND galleryID = ?";
      var inserts2 = [req.params.orderID, req.params.galleryID];
      paintingsDeleteSql = mysql.pool.query(paintingsDeleteSql, inserts2, function (error, results, fields) {
        if (error) { //if error, log it in the console
          console.log(error)
          res.write(JSON.stringify(error));
          res.status(400);
          res.end();
        } else { //if success, return 202 status
          res.status(202).end();
        }
      })
    }
  });
});

//UPDATE ORDERS PAGE
//page for the order that the user is wanting to update.
//Gets the order via the ID, sent back as datalist
app.get('/ordersUpdatePage', function (req, res, next) {
  var context = {};
  mysql.pool.query("SELECT * FROM Orders INNER JOIN Customers ON Orders.customerID = Customers.customerID WHERE orderID=?", [req.query.id], function (err, rows, fields) {
    if (err) { //if error, return error message
      next(err);
      return;
    }
    context.dataList = rows;

    //get the customers's
    mysql.pool.query('SELECT * FROM Customers', function (err, resultsCustomers, fields) {
      if (err) { //if error, retur error message
        console.log("Error getting galleries");
        return;
      }
      context.customers = resultsCustomers;

      res.render('updateOrders', context);
    })
  });
});

//UPDATING AN ORDER
//updates an order given the input from the user
//Will only update if a parameter is given. If it is left blank, the table will not update it and
// will retain whatever information was already in that position
app.get('/safeUpdateOrders', function (req, res, next) {
  var context = {};
  //make sure order exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Orders WHERE orderID=?", [req.query.orderID], function (err, result) {
    if (err) {
      next(err);
      return;
    }
    //update the order
    if (result.length == 1) {
      var curVals = result[0];
      mysql.pool.query("UPDATE Orders SET customerID=? WHERE orderID=? ",
        [req.query.customerID || curVals.customerID, req.query.orderID],
        function (err, result) {
          if (err) {
            next(err);
            return;
          }
          else { //if update successful, display console success message, then render order page
            context.results = "Updated " + result.changedRows + " rows.";
            res.render('orders', context);
          }
        });

    }
  });
});


//INSERTING AN ORDER
//Inserts an order into the Orders table with the given values from user
app.post('/orders', function (req, res) {
  //make sure customer exists first (if not, error and exit)
  mysql.pool.query("SELECT * FROM Customers WHERE customerID=?", [req.body.payloadCustomerID], function (err, checkResults) {
    if (err) {
      next(err);
      return;
    }
    if (checkResults.length == 0) //no artist found, return error
    {
      res.status(409);
      res.sendStatus(409);
    }
    else {
      //make sure painting exists first (if not, error and exit)
      mysql.pool.query("SELECT * FROM Paintings WHERE paintingID=?", [req.body.payloadPaintingID[0]], function (err, checkResults2) {
        if (err) {
          next(err);
          return;
        }
        if (checkResults2.length == 0) //no artist found, return error
        {
          res.status(400);
          res.sendStatus(400);
        }
        else {

          //insert the order into the orders table
          var sql = "INSERT INTO Orders (customerID) VALUES (?)";
          var inserts = [req.body.payloadCustomerID];

          sql = mysql.pool.query(sql, inserts, function (error, results, fields) {
            if (error) {
              res.write(JSON.stringify(error));
              res.end();
            }
            else { //then update the painting associated with order to add orderID
              mysql.pool.query('SELECT MAX (orderID) as maxID FROM Orders', function (error, tempResults, fields) {
                if (error) {
                  res.write(JSON.stringify(error));
                  res.end();
                }
                //grab the MAX orderID and store it in a variable:
                var newOrderID = tempResults[0].maxID;

                //get current paintingID to update/add
                var currPaintingID = req.body.payloadPaintingID[0];

                //Update the Paintings to reflect new order
                var newSql = "UPDATE Paintings SET orderID=? WHERE paintingID=?";
                var newInserts = [newOrderID, currPaintingID];
                newSql = mysql.pool.query(newSql, newInserts, function (error, results, fields) {
                  if (error) {
                    res.write(JSON.stringify(error));
                    res.end();
                  }
                });

                //udpate the OrdersToGalleries table to reflect new order
                mysql.pool.query("SELECT galleryID FROM Paintings WHERE paintingID = " + currPaintingID, function (error, tempResults2, field) {
                  if (error) {
                    res.write(JSON.stringify(error));
                    res.end();
                  }

                  //grab the galleryID to insert and store it in a variable:
                  var galleryIDtoInsert = tempResults2[0].galleryID;

                  //send an insert request to table
                  var newSql2 = "INSERT INTO OrdersToGalleries (orderID, galleryID) VALUES (?, ?)";
                  var inserts2 = [newOrderID, galleryIDtoInsert];
                  console.log("\nCreating a new order with order ID: " + newOrderID);
                  newSql2 = mysql.pool.query(newSql2, inserts2, function (error, results, fields) {
                    if (error) {
                      res.write(JSON.stringify(error));
                      res.end();
                    }
                  });
                  res.redirect("/orders");
                }
                )
              });
            };
          });
        };
      });
    };
  });
});



//INSERTING MORE PAINTINGS IN AN ORDER
//Inserts an order into the Orders table with the given values from user
app.post('/moreOrders', function (req, res) {
  mysql.pool.query('SELECT MAX (orderID) as maxID FROM Orders', function (error, tempResults, fields) {
    if (error) {
      res.write(JSON.stringify(error));
      res.end();
    }

    /* BAKCUP CHECK: In case the orderID is too low (doesn't register the new order from above post request, 
    it will add 1 to order. Server then checks if that newOrderID is a valid ID.
    If new orderID isn't valid (aka - everything above worked as planned), subtract 1 from
    our newOrderID*/
    var newOrderID = tempResults[0].maxID + 1;

    //if it finds the order ID (the ID we added 1 to above), keep using that ID. If not, subtract 1 to get to maxID
    mysql.pool.query('SELECT * FROM Orders WHERE orderID=? ' + newOrderID, function (error, orderResults, fields) {
      if (error) {
        newOrderID = newOrderID - 1;
      }

      //get current paintingID to update/add
      var currPaintingID = req.body.currentPayloadPaintingID;

      //make sure painting exists first (if not, error and exit)
      mysql.pool.query("SELECT * FROM Paintings WHERE paintingID=?", [currPaintingID], function (err, checkResults2) {
        if (err) {
          next(err);
          return;
        }
        if (checkResults2.length == 0) //no artist found, return error
        {
          res.status(400);
          res.sendStatus(400);
        }
        else {
          //Update the Paintings to reflect new order
          var newSql = "UPDATE Paintings SET orderID=? WHERE paintingID=?";
          var newInserts = [newOrderID, currPaintingID];
          console.log("More Paintings INSERTS (orderID), (paintingID): " + newInserts);
          newSql = mysql.pool.query(newSql, newInserts, function (error, results, fields) {
            if (error) {
              res.write(JSON.stringify(error));
            }
          });

          //udpate the OrdersToGalleries table to reflect new order
          mysql.pool.query("SELECT galleryID FROM Paintings WHERE paintingID = " + currPaintingID, function (error, tempResults2, field) {
            if (error) {
              res.write(JSON.stringify(error));
            }

            //grab the galleryID to insert and store it in a variable:
            var galleryIDtoInsert = tempResults2[0].galleryID;

            //send an insert request to table
            var newSql2 = "INSERT INTO OrdersToGalleries (orderID, galleryID) VALUES (?, ?)";
            var inserts2 = [newOrderID, galleryIDtoInsert];
            newSql2 = mysql.pool.query(newSql2, inserts2, function (error, results, fields) {
              if (error) {
                res.write(JSON.stringify(error));
              }
            });
          }
          )
        }
      });
    });
  });
});




//MAIN Orders PAGE
//Gets all orders from the data base, returns it as dataList
app.get('/orders', function (req, res) {
  var context = {};
  //get the current orders table
  mysql.pool.query('SELECT * FROM Orders INNER JOIN Customers ON Orders.customerID = Customers.customerID ORDER BY orderID', function (err, rows, fields) {
    if (err) { //if error, retur error message
      console.log("Error getting orders");
      return;
    }
    context.dataList = rows;


    //get the ordersToGalleries table
    mysql.pool.query('SELECT * FROM OrdersToGalleries INNER JOIN Galleries ON OrdersToGalleries.galleryID = Galleries.galleryID ORDER BY orderID', function (err, resultsMM, fields) {
      if (err) { //if error, retur error message
        console.log("Error getting OrdersToGalleries");
        return;
      }
      context.dataListMToM = resultsMM;

      //get the customerID's
      mysql.pool.query('SELECT customerID, customerFirstName, customerLastName FROM Customers', function (err, resultsCustomers, fields) {
        if (err) { //if error, retur error message
          console.log("Error getting paintings");
          return;
        }
        context.customers = resultsCustomers;
      });

      //get the paintingID's
      mysql.pool.query('SELECT paintingID, artType FROM Paintings WHERE orderID IS NULL', function (err, resultsPaintingsForSale, fields) {
        if (err) { //if error, retur error message
          console.log("Error getting paintings");
          return;
        }
        context.paintings = resultsPaintingsForSale;

        //finally, render the orders page
        res.render('orders', context);
      });
    });
  });
});




//-------------------SEARCH SECTION--------------------------------------------------------------//

//search page
app.get('/search', function (req, res, next) {
  var context = {};
  context.dataList = [
  ];
  res.render('search', context);
});

var urlencodedParser = bodyParser.urlencoded({ extended: false })

app.post('/search', urlencodedParser, function (req, res) {
  var context = {}
  var Search = req.body.searchForm
  var SearchDatabase = req.body.check
  var SearchType = ""
  //Search = '\'' + Search + '\''
  if (SearchDatabase == "Customers") {
    SearchType = "customerLastName"
  }
  else if (SearchDatabase == "Paintings") {
    SearchType = "paintingID"
  }
  else if (SearchDatabase == "Orders") {
    SearchType = "orderID"
  }
  else if (SearchDatabase == "Artists") {
    SearchType = "artistLastName"
  }
  else if (SearchDatabase == "Galleries") {
    SearchType = "galleryID"
  }

  mysql.pool.query('SELECT * FROM '.concat(SearchDatabase, ' WHERE ', SearchType, ' = \"' + Search + '\"'), function (err, results, fields) {
    if (err) { //if error, return error message
      console.log("Error getting search");
      context.error = [{ error: "Missing checkbox or text input" }]
      res.render('search', context);
    }
    else if (results) {
      if (results[0] == null) {
        context.error = [{ error: "Search Result Not Found; " + SearchType + " of " + Search + " Does Not Exist" }]
      }
      context.dataList = results
      res.render('search', context);
    }
  })
})




//-------------------SERVER SECTION--------------------------------------------------------------//
app.use(function (req, res) {
  res.status(404);
  res.render('404');
});

app.use(function (err, req, res, next) {
  console.error(err.stack);
  res.status(500);
  res.render('500');
});

app.listen(app.get('port'), function () {
  console.log('Express started on flip1.engr.oregonstate.edu:' + app.get('port') + ' OR localhost:' + app.get('port') + '; press Ctrl-C to terminate.');
});
               
        </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">Art Gallery Database website</p>
            <img class="codeExampleIcon" src="./images/html5Icon.jpeg">
            <img class="codeExampleIcon" src="./images/CSSIcon.jpeg">
            <img class="codeExampleIcon" src="./images/javascriptIcon.jpeg">
            <img class="codeExampleIcon" src="./images/ajaxIcon.jpeg">
            <img class="codeExampleIcon" src="./images/nodejsIcon.png">
            <img class="codeExampleIcon" src="./images/handlebarsIcon.png">
            <img class="codeExampleIcon" src="./images/mysqlIcon.png">
            <br><br>
            <span class="codeTableInnerText">This project was created to develop skills in database development. This
              fictional Art Gallery is based on the idea of a coop of art galleries who sell paintings
              and need to keep track of their inventory,
              artists, customers and orders. The main part of this project was to create and setup a MySQL server,
              connect it to a backend server running Javascript, which in turn sends information to the user's
              website.<br><br>

              Frontend development is using HTML5, CSS and Javascript. Backend development
              is using Node.js, Express, Handlebars, and MySQL.
              The table also uses AJAX when deleting.<br><br>
              The code seen here is the node.js code for the backend of the website. Please see full code for website
              examples.
            </span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/PORTFOLIO-Web-Development-HTML5-CSS-Node.js-JavaScript-C-Cpp-Rust-Assembly-Language/tree/main/Web%20Design/ArtGallery">Full
                Code</a></p>
          </td>
        </tr>
      </table>
    </div>

    <br>

    <!--- Minesweeper Game -->
    <div class="codeExamplesClassReveal" id="minesweeperReveal">
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
            <pre class="codeExampleInnerBox">
//Patrick Stumbaugh
//Minesweeper game

#include &ltiostream>
#include &ltstdlib.h>
#include &lttime.h>
#include &ltstdio.h>

using namespace std;

//global constants
int SIZE; //length of the board (SIZE x SIZE)
int MINES; //amount of mines in play
const int MAXSIDE = 25;
const int MAXMINES = 99;
int mmx = -1;
int mmy = -1;
bool mm = false;

//function declarations
void gameSetup(char masterBoard[][MAXSIDE], char playerBoard[][MAXSIDE]);
void placeMines(int mines[][2], char masterBoard[][MAXSIDE]);
bool checkPosition (int row, int col);
bool mineCheck (int row, int col, char board[][MAXSIDE]);
void makeMove(int &x, int &y);
void checkMoveBounds(int &x, int &y);
bool moveMine (int row, int col, char board[][MAXSIDE],
        char masterBoard[][MAXSIDE]);
void printBoard(char playerBoard[][MAXSIDE]);
int adjacentMineCheck(int row, int col, int mines[][2],
        char masterBoard[][MAXSIDE]);
void playGame();
bool MSutility(char playerBoard[][MAXSIDE], char masterBoard[][MAXSIDE],
        int mines[][2], int row, int col, int &movesLeft);
void getGameSize();
void printRules();


int main()
{
    cout &lt&lt endl &lt&lt endl &lt&lt "Welcome to Minesweeper!" &lt&lt endl;
    printRules();
    getGameSize(); //prompts user for size of board
    playGame();
    cout &lt&lt endl &lt&lt endl;
    return 0;
}

//*******************FUNCTIONS*******************

//initializes a new, empty board for player
//INPUT: masterBoard array and playerBoard array
//OUTPUT: nothing
void gameSetup(char masterBoard[][MAXSIDE], char playerBoard[][MAXSIDE])
{
    // Initiate the random number generator so that
    // the same configuration doesn't arises
    srand(time (NULL));
  
    // Initialize all cells to empty (will add mines later in seperate func)
    for (int i = 0; i &lt= SIZE; i++)
    {
        for (int j = 0; j &lt= SIZE; j++)
        {
            playerBoard[i][j] = masterBoard[i][j] = '-';
        }
    }
    return;
}


//Places mines randomly throughout board
//INPUT: mines array, masterBoard array
//OUTPUT: nothing
void placeMines(int mines[][2], char masterBoard[][MAXSIDE])
{
    bool mark[MAXSIDE*MAXSIDE];
    int temp = MAXSIDE*MAXSIDE;
    for (int a = 0; a &lt= temp; a++)
    {
        mark [a] = false;
    }
  
  
    // Continue until all random mines have been created.
    for (int i = 0; i &lt MINES; )
      {
        int random = rand() % (SIZE*SIZE);
        int x = random / SIZE;
        int y = random % SIZE;
  
        // Add the mine if no mine is placed at this
        // position on the board
        if (mark[random] == false)
        {
            // Row for the mine
            mines[i][0] = x;
            // Column for the mine
            mines[i][1] = y;
  
            // Place mine
            masterBoard[mines[i][0]][mines[i][1]] = '*';
            mark[random] = true;
            i++;
        }
    }
    return;
}


//Check if a cell is valid/available to play
//INPUT: row and column
//OUTPUT: True is valid position, else false
bool checkPosition(int row, int col)
{
    if ((row >= 0) && (row &lt SIZE) && (col >= 0) && (col &lt SIZE))
        return true;
    else
        return false;
}


//checks if position selected has a mine or not
//INPUT: row, column and board array
//OUTPUT: true if a mine is at that position, else false
bool mineCheck (int row, int col, char board[][MAXSIDE])
{
    if (board[row][col] == '*')
        return true;
    else
        return false;
}
  

//Input user's move
//INPUT: x and y positions
//OUTPUT: nothing
void makeMove(int &x, int &y)
{
    // Take the input move
    cout &lt&lt "Enter your move" &lt&lt endl;
    cout &lt&lt "Row: ";
    cin >> x;
    cout &lt&lt "Column: ";
    cin >> y;
    return;
}


void checkMoveBounds(int &x, int &y)
{
    if ((x &lt 0) || (x >= SIZE) || (y &lt 0) || (y >= SIZE))
    {
    cout &lt&lt "Invalid input, please try again." &lt&lt endl;
        makeMove(x, y);
        checkMoveBounds(x, y);
    }
    else
        return;
}


//Moves a mine to a different position
//guarentees player's first move will not result in a mine position
//INPUT: row, column and board array
//OUTPUT: nothing
bool moveMine (int row, int col, char board[][MAXSIDE],
    char masterBoard[][MAXSIDE])
{
    //iterate to first empty location, replace that with a mine
    //make player's location an empty position
    for (int i = 0; i &lt SIZE; i++)
    {
        for (int j = 0; j &lt SIZE; j++)
            {
                if (masterBoard[i][j] != '*')
                {
                    masterBoard[i][j] = '*';
                    masterBoard[row][col] = '-';
                    return true;
                }
            }
    }
    return false;
}


//Prints the current board
//INPUT: playerBoard array
//OUTPUT: displays board
void printBoard(char playerBoard[][MAXSIDE])
{
    int i, j;
  
    cout &lt&lt ("      ");
  
    for (i = 0; i &lt SIZE; i++) //print top column numbers
    {
        if (i >= 10)
            cout &lt&lt " " &lt&lt i &lt&lt ".";
        else
            cout &lt&lt "  " &lt&lt i &lt&lt ".";
    }
  
    cout &lt&lt endl;
  
    for (i = 0; i &lt SIZE; i++)
    {
        if (i >= 10)
        {
            cout &lt&lt "  " &lt&lt i &lt&lt "."; //print row number
      
            for (j = 0; j &lt SIZE; j++)
                cout &lt&lt "   " &lt&lt playerBoard[i][j]; //print out items in that row
            cout &lt&lt endl; //heading to next row, new line
        }
        else
        {
            cout &lt&lt "   " &lt&lt i &lt&lt "."; //print row number
      
            for (j = 0; j &lt SIZE; j++)
                cout &lt&lt "   " &lt&lt playerBoard[i][j]; //print out items in that row
            cout &lt&lt endl; //heading to next row, new line


        }
    }
    return;
}
  
  
//Counts the number of mines in the 8 adjacent cells to user's position
//INPUT: row, column, mines array, masterBoard array
//OUTPUT: count of mines near user's position
int adjacentMineCheck(int row, int col, int mines[][2],
                                char masterBoard[][MAXSIDE])
{
    int count = 0;
  
//if cell is not valid (ie - outside board bounds), ignore
//North neighbour
        if (checkPosition (row-1, col) == true)
        {
                if (mineCheck (row-1, col, masterBoard) == true)
                count++;
        }
  //South neighbour
        if (checkPosition (row+1, col) == true)
        {
                if (mineCheck (row+1, col, masterBoard) == true)
                count++;
        }


//East neighbour
        if (checkPosition (row, col+1) == true)
        {
            if (mineCheck (row, col+1, masterBoard) == true)
                count++;
        }
  
//West neighbour
        if (checkPosition (row, col-1) == true)
        {
                if (mineCheck (row, col-1, masterBoard) == true)
                count++;
        }
  
//NE neighbour
        if (checkPosition (row-1, col+1) == true)
        {
            if (mineCheck (row-1, col+1, masterBoard) == true)
                count++;
        }
  
//NW neighbour
        if (checkPosition (row-1, col-1) == true)
        {
              if (mineCheck (row-1, col-1, masterBoard) == true)
                count++;
        }
  
//SE neighbour
        if (checkPosition (row+1, col+1) == true)
        {
                if (mineCheck (row+1, col+1, masterBoard) == true)
                count++;
        }
  
//SW neighbour
        if (checkPosition (row+1, col-1) == true)
        {
            if (mineCheck (row+1, col-1, masterBoard) == true)
                count++;
        }
  
    return (count);
}


//Play the minesweeper game
//NOTE - if player's first pick ims a mine, the game will move the mine.
//INPUT: nothing
//OUTPUT: nothing
void playGame ()
{
    //initialize variables / arrays
    bool gameOver = false;
    char masterBoard[MAXSIDE][MAXSIDE]; //gamemaster's board
    char playerBoard[MAXSIDE][MAXSIDE]; //players board
    int movesLeft = ((SIZE * SIZE) - MINES); //size of board minus minus
    int x;
    int y;
    int currentMove = 0;
    int mines[MAXMINES][2]; // will store position for all mines.
  
    //setup the gamemaster and player boards (all empty positions)
    gameSetup(masterBoard, playerBoard);
  
    //place the mines randomly on gamemaster's board
    placeMines (mines, masterBoard);
    
    while (gameOver == false)
    {
        cout &lt&lt "Current board :" &lt&lt endl;
        printBoard (playerBoard); //shows player's board
        makeMove (x, y); //Prompts player to pick position for mine
        checkMoveBounds(x, y); //checks the player's input


        //if first move of game == mine position, move that mine
        //guarentee's player's first move will be available
        if (currentMove == 0)
        {
            if (mineCheck(x, y, masterBoard) == true)
            {
                mm = moveMine(x, y, playerBoard, masterBoard);
                mmx = x;
                mmy = y;
            }
        }
        currentMove ++;
      
        gameOver = MSutility(playerBoard, masterBoard, mines, x, y, movesLeft);
      
        if (movesLeft &lt 0)
            movesLeft = movesLeft * -1;
        
        if ((gameOver == false) && (movesLeft == 0)) //player won!
        {
            printBoard (playerBoard);
            cout &lt&lt endl &lt&lt "You won!" &lt&lt endl;
            cout &lt&lt "Thank you for playing!" &lt&lt endl;
            gameOver = true;
        }


        if ((gameOver == true) && (movesLeft != 0)) //player lost
        {
            if (masterBoard[x][y] == '*')
            {
                playerBoard[x][y]='*';
              
                for (int i=0; i&ltMINES; i++)
                    playerBoard[mines[i][0]][mines[i][1]]='*';
                    
                if (mm == true) //original position was swapped
                {
                    int mmPosition =
                    adjacentMineCheck(x, y, mines, masterBoard) + 1 + '0';
                    playerBoard[mmx][mmy] = mmPosition;
                    printBoard (playerBoard);
                }
                else
                    printBoard (playerBoard);
            }
            cout &lt&lt "You lost." &lt&lt endl;
            cout &lt&lt "Better luck next time!" &lt&lt endl;
            cout &lt&lt "Thank you for playing!" &lt&lt endl;
        }
        //else continue playing...
    }
    return;
}


//Utility function to play minesweeper game (compares player's board to
// masterBoard)
//***Recursively moves until mine enountered
//INPUT: playerBoard, masterBoard and mines arrays, row, column and movesLeft
//OUTPUT: True if player picks a mine position (ends game), else false
bool MSutility(char playerBoard[][MAXSIDE], char masterBoard[][MAXSIDE],
            int mines[][2], int row, int col, int &movesLeft)
{


    //if not empty position, return false
    //base case ends (later) recurisve calls
    if (playerBoard[row][col] != '-')
        return false;


    //if player (or later recursion) picked position with a mine, return true
    if (masterBoard[row][col] == '*')
    {
        return true;
    }
    
    //else find adjacent free cells
    else
    {
    // Calculate the number of adjacent mines and put it on the board
        int count = adjacentMineCheck(row, col, mines, masterBoard);
        movesLeft--;
  
        playerBoard[row][col] = count + '0';
  
        if (!count)
        {
//if cell is not valid (ie - outside board bounds), ignore
//N neighbour
            if (checkPosition (row-1, col) == true)
            {
                    if (mineCheck (row-1, col, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row-1, col, movesLeft);
            }
  
//S neighbour
            if (checkPosition (row+1, col) == true)
            {
                    if (mineCheck (row+1, col, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row+1, col, movesLeft);
            }
  
//E neighbour
            if (checkPosition (row, col+1) == true)
            {
                if (mineCheck (row, col+1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row, col+1, movesLeft);
            }
  
//W neighbour
            if (checkPosition (row, col-1) == true)
            {
                    if (mineCheck (row, col-1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row, col-1, movesLeft);
            }
  
//NE neighbour
            if (checkPosition (row-1, col+1) == true)
            {
                if (mineCheck (row-1, col+1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row-1, col+1, movesLeft);
            }
  
//NW neighbour
            if (checkPosition (row-1, col-1) == true)
            {
                  if (mineCheck (row-1, col-1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row-1, col-1, movesLeft);
            }
  
//SE neighbour
            if (checkPosition (row+1, col+1) == true)
            {
                  if (mineCheck (row+1, col+1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row+1, col+1, movesLeft);
            }
  
//SW neighbour
            if (checkPosition (row+1, col-1) == true)
            {
                if (mineCheck (row+1, col-1, masterBoard) == false)
                    MSutility(playerBoard, masterBoard, mines, row+1, col-1, movesLeft);
            }
        }
        return false;
    }
}


//Prompts user for the size of the gameboard
//Note - # of mines in game is the same as one side of the board
// ie - 9x9 board = 9 mines. 20x20 board = 20 mines
//INPUT: nothing
//OUTPUT: nothing (changes global variables SIZE and MINES)
void getGameSize ()
{
    //user input must be >= 2 and &lt 25
    while ((SIZE &lt= 2) || (SIZE > 25))
    {
        cout &lt&lt "Enter the size of the game you would like to play ";
        cout &lt&lt "(min = 3, max = 25)." &lt&lt endl;
        cout &lt&lt "(example: 9 = 9x9 board)" &lt&lt endl;
        cout &lt&lt "size: ";
        cin >> SIZE;
        MINES = SIZE;
        if ((SIZE &lt= 2) || (SIZE > 25))
            cout &lt&lt "Invalid input, please try again." &lt&lt endl &lt&lt endl;
    }
    return;
}


//Prints out the rules of the game
//INPUT: nothing
//OUTPUT: nothing
void printRules()
{
    cout &lt&lt "RULES OF MINESWEEPER:" &lt&lt endl;
    cout &lt&lt "1. Don't pick a mine, or your game will be over!" &lt&lt endl;
    cout &lt&lt "2. If you pick a spot that is not a mine, you'll get a number. ";
    cout &lt&lt "That number will tell you how many adjacent cells have mines. "
            "Use that number (and maybe some luck) to guess where more open "
            "cells will be." &lt&lt endl;
    cout &lt&lt "3. If you open a cell with 0 neighboring mines, all the "
            "neighbors will automatically open." &lt&lt endl;
    cout &lt&lt "4. You win once all the cells without mines are found!" &lt&lt endl;


    
    cout &lt&lt endl;
    return;
}
                       
    </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">Minesweeper game</p>
            <img class="codeExampleIcon" src="./images/c++Icon.jpeg">
            <br><br>
            <span class="codeTableInnerText">This is a simple buildout of a minesweeper game that runs through console.
              It is built using C++. <br><br>
              This was designed to implement different types of algorithms as well as an example of recursion. <br><br>
              This is the full code, so if you would like to play it, feel free to copy and paste in your own compiler.
            </span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/Portfolio/tree/main/C%2B%2B/Minesweeper%20Game">Full Code</a></p>
          </td>
        </tr>
      </table>
    </div>

    <br>

    <!-- Small Shell -->
    <div class="codeExamplesClassReveal" id="smallShellReveal">
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
            <pre class="codeExampleInnerBox">
//Patrick Stumbaugh

//create using:
    // gcc --std=gnu99 -o smallsh main.c
//then run using:
    // ./smallsh

#include &ltsys/wait.h>
#include &ltsys/types.h>
#include &ltsys/stat.h>
#include &ltunistd.h>
#include &ltstdio.h>
#include &ltstdlib.h>
#include &ltfcntl.h>
#include &ltstring.h>
#include &ltsignal.h>
#include &ltstdbool.h>

//global variables
char* inputFile = NULL; //input file's name
char* outputFile = NULL; //output files's name
int status; //placeholder for exit status
int foregroundModeFlag = 0; //Flag for foreground only mode
int backgroundCounter = 0; //counter to keep track of background processes

// Signal actions
struct sigaction SIGINT_action = {0};
struct sigaction SIGTSTP_action = {0};

//function declarations
void runningLoop(char* homeDir);
void checkForProcesses(int* backgroundPIDs);
char* getInputLine();
char** parseInputLine(char *userInput, int* inputFlag, int* outputFlag, int* inputFileFlag, int* backgroundFlag);
void runCommands(char** parsed, int* inputFlag, int* outputFlag, char* homeDir, int* inputFileFlag, bool* continueRunning, int* backgroundFlag, int* backgroundPIDs);
void replaceWithPID(char *source, const char *searchFor, const char *replaceWith);
void addBgPID(int pidno, int* backgroundPIDs);
void removeBgPID(int pidno, int* backgroundPIDs);
void foregroundOnlyMode(int signo);
void freeMemPointer(char* file);
void freeMem2xPointer(char** file);


/*Main program will prompt user for a command. It will then parse the line
that the user entered into different tokens, store those in a seperate char
array, then execute those commands based on what is asked for. If a command
ends with "&" it will be sent to the background processes.
*/
int main (int argc, char* argv[]) 
{
  // get the home directory (from this program's environment variables)
    char* homeDir = getenv("HOME");
  
  //Initialize SITGINT
  SIGINT_action.sa_handler = SIG_IGN;
  sigaction(SIGINT, &SIGINT_action, NULL);


  //Initialize SIGTSTP (foreground-only)
  SIGTSTP_action.sa_handler = foregroundOnlyMode;
  sigfillset(&SIGTSTP_action.sa_mask);
  SIGTSTP_action.sa_flags = SA_RESTART;
  sigaction(SIGTSTP, &SIGTSTP_action, NULL);
  
  //Get input from user, do work, loop around until user enters "exit"
  //(this is the main workhorse of the program)
  runningLoop(homeDir);


  return 0;
}


/**************************************************************************
    FUNCTIONS
**************************************************************************/


//Main looping function - gets input from the user, parses that, checks for 
//running background processes, then executes commands. Loops until user
//enters "exit" command 
//INPUT: nothing 
//OUTPUT: nothing
void runningLoop(char* homeDir) 
{
  int inputFlag = 0; //flag if input file name is received (1 if true)
  int outputFlag = 0; //flag if output file name is received (1 if true)
  int inputFileFlag = 0; //flag if an input file is given (1 if true)
  bool continueRunning = true; //loop bool to continue running 
  char *userInput = NULL; //line to hold user's input
  char **parsed = NULL; //array to hold user's input parsed into seperate commands
  int backgroundFlag = 0; //background processes flag (1 if background process)
  int backgroundPIDs[100]; //storage array for background PID numbers

  while(continueRunning == true) 
  {
    int stdin_save = dup(STDIN_FILENO); // save stdin position
      int stdout_save = dup(STDOUT_FILENO); // save stdout position


    // Check background processes
    if (backgroundCounter > 0) 
    {	
      checkForProcesses(backgroundPIDs);
    }
    
    // Handle input
    userInput = getInputLine();
    parsed = parseInputLine(userInput, &inputFlag, &outputFlag, &inputFileFlag, &backgroundFlag);
    runCommands(parsed, &inputFlag, &outputFlag, homeDir, &inputFileFlag, &continueRunning, &backgroundFlag, backgroundPIDs);
    
    
    //free memory stored from last command line input
    freeMemPointer(userInput); //also frees inputFile if made
    freeMem2xPointer(parsed);


        //reset input and output file names and flags
    inputFile = NULL;
    outputFile = NULL;
    userInput = NULL;
    parsed = NULL;
      outputFlag = 0;
      inputFlag = 0;
      inputFileFlag = 0;
      
      dup2(stdout_save, STDOUT_FILENO); // restore standard out
        dup2(stdin_save, STDIN_FILENO); // restore standard in 
  }
}


//Function to check if there are any background processes that have 
//finished running. If so, print that they have finished
//INPUT: nothing
//OUTPUT: nothing
void checkForProcesses(int* backgroundPIDs) 
{
  // Check to see if a background process terminated
  pid_t bgPIDrunning;
  //see if any background processes are finished (if true, bgPIDrunning > 0)
  bgPIDrunning = waitpid(-1, &status, WNOHANG); 
  
  while (bgPIDrunning > 0) //if > 0, there is a background process done running
  {
    // If so, remove it from the array
    removeBgPID(bgPIDrunning, &*backgroundPIDs);
    
    // if it exited normally, print status
    if (WIFEXITED(status)) 
    {
      printf("background pid %d is done. exit value %d\n", bgPIDrunning, WEXITSTATUS(status)); 
      fflush(stdout);
    } 
    else if (WIFSIGNALED(status)) //if exited by signal, print signal 
    {
      printf("background pid %d is done. terminated by signal %d\n", bgPIDrunning, WTERMSIG(status)); 
      fflush(stdout);	
    }
    
    // Recheck background processes finished. If more, loop
    bgPIDrunning = waitpid(-1, &status, WNOHANG);
  }	
}


/*Prompt and get a command line from the user. 
Check if that line has "$$" in it. 
If it does, repalce it with the PID number currently being run */
//INPUT: nothing
//OUTPUT: string for the line of commands from user
char* getInputLine() 
{
  // Prompt the user for a new line of commands
  printf(": ");
  fflush(stdout);
  
  // Save the user's input into a char pointer "userInput"
  char *userInput = NULL;
  size_t bufsize = 0;
  getline(&userInput, &bufsize, stdin);
  
  //check if we need to replace any "$$" with PID number
  char *pidCheck = strstr(userInput, "$$");
  if (pidCheck != NULL) 
  {
    char alteredString[50];
    sprintf(alteredString, "%d", getpid());
    replaceWithPID(userInput, "$$", alteredString);
  }
  return userInput;
}


//Iterates through user's input line of commands, parses those commands into 
//seperate char pointers, stores in parsed array for later use (with exec...)
//INPUT char* userInput 
//OUTPUT parsed array
char** parseInputLine(char *userInput, int* inputFlag, int* outputFlag, int* inputFileFlag, int* backgroundFlag) 
{
  //allocate memory for parsed array
  char **parsed = malloc(100 * sizeof(char*)); 
  
  char *token; 
  char *prevToken = NULL;
  int position = 0;
  char* delim = " \t\r\n\a"; //used to seperate tokens
  
  // seperate userInput string into tokens
  token = strtok(userInput, delim);
    
  while (token != NULL) {
    
    // Output redirection
    if (strcmp(token, ">") == 0) {
      *outputFlag = 1;
      
      int input_fd = open(parsed[position-1], O_RDONLY);
      if (input_fd != -1) //error, assume there's a file it found 
      {
          *inputFileFlag = 1;
          inputFile = prevToken;
      }
      
      outputFile = strtok(NULL, delim);
      
      token = strtok(NULL, delim);
      parsed[position] = NULL;
      position++;
      continue;
    }
    
    // Input redirection
    if (strcmp(token, "&lt") == 0) {
      *inputFlag = 1;
      
      inputFile = strtok(NULL, delim);
      token = strtok(NULL, delim);
      parsed[position] = NULL;
      position++;
      continue;
    }
    
    // Background process
    if (strcmp(token, "&") == 0) {
      parsed[position] = NULL;
      if (foregroundModeFlag) 
      {
        *backgroundFlag = 0;
      } else 
      {
        *backgroundFlag = 1;
      }
      break;
    }			
    
    // Add to arguments
    parsed[position] = token; 
    position++;
    prevToken = token;
    token = strtok(NULL, delim);
  }
  
  // Set last argument to NULL
  parsed[position] = NULL;
  return parsed;
}


//Executes commands (first checks for built in commands, if not matching,
//send to launch to execute shell commands)
//INPUT: char **parsed, int* inputFlag, int* outputFlag, char* homeDir
//OUTPUT: nothing
void runCommands(char** parsed, int* inputFlag, int* outputFlag, char* homeDir, int* inputFileFlag, bool* continueRunning, int* backgroundFlag, int* backgroundPIDs)
{
    //variables to save PID numbers
    pid_t spawnPid;
  pid_t waitPid;
  
    //If it's a blank line or comment
  if (parsed[0] == NULL) //if blank line, don't do anything
  {
      return;
  } 
  else if (strcmp(parsed[0], "#") == 0) //if line starts with #, don't do anything (comment line)
  {
      return;
  }
  else if (strcmp(parsed[0], "exit") == 0) //check for exit command
  {
    while (backgroundCounter > 0) 
    {
      kill(backgroundPIDs[0],SIGTERM); //kill background process (if true) (using SIGTERM)
      removeBgPID(backgroundPIDs[0], backgroundPIDs); //remove background process kill from count / array
    }
    *continueRunning = false; //switch to false to exit runningLoop() and return to main
    
  } 
  else if (strcmp(parsed[0], "cd") == 0) //check for change directory command
  {
    //if no directory listed, change to home directory (homeDir)
    if (parsed[1] == NULL) 
    {
      if(chdir(homeDir) != 0) 
      {
        perror("chdir error"); //if error, print
        fflush(stdout);
      }
    } 
    else //change to directory listed by user 
    {
      if(chdir(parsed[1]) != 0) //if user directory not found...
      {
        perror("chdir error");//...print error
        fflush(stdout);
      }
    }	
  } 
  else if (strcmp(parsed[0], "status") == 0) //if status call, show last exit status
  {	
    if (WIFEXITED(status)) //check if last exited normally
    {
      printf("exit value %d\n", WEXITSTATUS(status));
      fflush(stdout);
    } 
    else if (WIFSIGNALED(status)) //else, check if exited by terminating signal
    {
      printf("terminated by signal %d\n", WTERMSIG(status));
      fflush(stdout);	
    }
  } 
  else //run exec... depending on what command is given
  {
      spawnPid = fork(); //fork child
      
      switch(spawnPid)
      {
          case -1: //fork didn't work, exit
          {
            perror("fork");
            fflush(stdout);
            exit(1);
          }
          case 0: //fork worked, child process running this
          {
            fflush(stdout);
        
            // Set input if specified
            if (*inputFlag) //if there is an input file, open and read it
            {
              int fd0 = open(inputFile, O_RDONLY); //open input file read only
              if (fd0 == -1) //if error opening input file, display error
              {
                printf("cannot open %s for input\n", inputFile);
                fflush(stdout);
                exit(1);
              } 
              else 
              {
                if (dup2(fd0, STDIN_FILENO) == -1)  //redirect stdin to input file descriptor
                {
                  perror("dup2");
                  fflush(stdout);
                }
                close(fd0);	
              }
            }
        
            if (*outputFlag) //if redirecting to output file
            {
                //open output file, create if new, append if already there. Read / write permissions
                int fd1 = open(outputFile, O_WRONLY | O_CREAT | O_APPEND, 0600);
              if (fd1 == -1) //if error creating output file, display error
              {
                printf("cannot create %s for output\n", outputFile);
                fflush(stdout);
                exit(1);			
              } 
              else //
              {
                if (dup2(fd1, STDOUT_FILENO) == -1) //redirect stout to output file descriptor
                {
                  perror("dup2");
                  fflush(stdout);
                }
                close(fd1);	
              }
            }
            
            
            if (*backgroundFlag) // if working in background
            {
                //set input and output to /dev/null for input/output in background
              if (!*inputFlag) //if no input file specified
              {
                int bgFDinput = open("/dev/null", O_RDONLY); //open read only
                if (bgFDinput == -1) {
                  printf("cannot open for input\n");
                  fflush(stdout);
                  exit(1);
                } 
                else 
                {
                  if (dup2(bgFDinput, STDIN_FILENO) == -1) 
                  {
                    perror("dup2");
                  }
                  close(bgFDinput); //close file	
                }	
              }
              
              // Set output to dev/null if not specified
              if (!*outputFlag) 
              {
                int bgFDoutput = creat("/dev/null", 0600); //create for ready/write
                if (bgFDoutput == -1) 
                {
                  printf("cannot set output\n");
                  fflush(stdout);
                  exit(1);			
                } 
                else 
                {
                  if (dup2(bgFDoutput, STDOUT_FILENO) == -1) 
                  {
                    perror("dup2");
                    fflush(stdout);
                  }
                  close(bgFDoutput);	
                }
              }	
            }
    
            // set SIGINT to foreground
            if (!*backgroundFlag) 
            {
              SIGINT_action.sa_handler = SIG_DFL;
              SIGINT_action.sa_flags = 0;
              sigaction(SIGINT, &SIGINT_action, NULL);
            }
            
            //execute commands (first check if using file for redirection)
            if (*inputFileFlag == 1) //if an input file is found (using redirect with file)
            {
                if(execlp("cat", outputFile, inputFile, NULL) == -1)
                    {
                        perror("Error executing command.");
                        fflush(stdout);
                    }
                    *inputFileFlag = 0; //reset inputFileFlag to 0
            }
            
            // execute all other commands
            else if (execvp(parsed[0], parsed)) 
            {
              perror(parsed[0]);
              fflush(stdout);
              exit(1);		
            }
          
          } 
          
          default: //parent process
          {
            if (!*backgroundFlag) //if not in background
            {
              do 
              {
                  //wait for any foreground processes to finish running (child process)
                waitPid = waitpid(spawnPid, &status, WUNTRACED); 
        
                if (waitPid == -1) //if error waiting, display error
                { 
                  perror("waitpid"); 
                  fflush(stdout);
                  exit(1); 
                }
                
                if (WIFSIGNALED(status)) //if process terminated by signal, display results
                {
                  printf("terminated by signal %d\n", WTERMSIG(status));
                  fflush(stdout);
                }
                
                if (WIFSTOPPED(status))  //if stopped by signal, display results
                {
                  printf("stopped by signal %d\n", WSTOPSIG(status));
                  fflush(stdout);
                }
        
              } 
              while (!WIFEXITED(status) && !WIFSIGNALED(status)); //while still running processes
          
            } 
            else //background mode on
            {
              printf("background pid is %d\n", spawnPid); //display background PID #
              fflush(stdout); 
              addBgPID(spawnPid, backgroundPIDs); //add background PID to array storing running bg processes
              *backgroundFlag = 0; // reset to point to foreground
            }
          }
      }
  }
    return;
}


//Replaces "$$" with pid in the source string 
//parts borrowed from stackoverflow.com
//INPUT: char *source, const char *searchFor, const char *replaceWith
//OUTPUT: nothing
void replaceWithPID(char *source, const char *searchFor, const char *replaceWith) 
{
  char buffer[2048] = {0}; //holding buffer
    char *insertPos = &buffer[0]; //starting insert point into buffer
    const char *tempArray = source; //temp char pointer
    size_t lenSearchFor = strlen(searchFor); //for this program, this is "$$"
    size_t lenReplaceWith = strlen(replaceWith); //PID # to replace "$$"
  
    while (1) //loop until it finds the item to replace (repeat until no more $$)
    {
    // See if our array has any "$$" in it
        const char *result = strstr(tempArray, searchFor);
        
    // No more "$$" found, copy over and exit function 
        if (result == NULL) 
        {
            strcpy(insertPos, tempArray); //copy our new string over the original
            break;
        }


        // Copy first part of string into a holding spot
        memcpy(insertPos, tempArray, result - tempArray);
        insertPos += result - tempArray;


        // Copy the PID into the "$$" position
        memcpy(insertPos, replaceWith, lenReplaceWith);
        insertPos += lenReplaceWith;


        // move the pointer up (new result + size of the PID we repalced "$$" with)
        tempArray = result + lenSearchFor;
    }


    // Copy the new string (buffer) back over the original string
    strcpy(source, buffer);
}


  //If background process called, add it's process number to the bg array tracker
  //INPUT: int pidno
  //OUTPUT: nothing
void addBgPID(int pidno, int* backgroundPIDs) 
{
  
    backgroundPIDs[backgroundCounter] = pidno;
  backgroundCounter++;	
}


//If a background process completes / exits, remove it from our background 
//array tracker
//INPUT: int pidno
//OUTPUT: nothing
void removeBgPID(int pidno, int* backgroundPIDs) 
{
    //loop through background array (backgroundPIDs[]) until it finds the pid number
    //that is needing to be removed
    for (int i = 0; i &lt backgroundCounter; i++) 
    {
    if (backgroundPIDs[i] == pidno) //pid number found, remove it
    {
      while (i &lt backgroundCounter - 1) //move array items over one position
      {
        backgroundPIDs[i] = backgroundPIDs[i + 1];
        i++;
      }
      backgroundCounter--; //remove 1 from background processes counter
      break;
    }
    }
    return;
}


//Enters or exits foreground-only mode depending on SIGTSTP
//INPUT: int signo 
//OUTPUT: nothing
void foregroundOnlyMode(int signo) 
{
  //enter the foreground-only mode
  if (foregroundModeFlag == 0) 
  {	
    char *message = "\nEntering foreground-only mode (& is now ignored)\n";
    write(STDOUT_FILENO, message, 50);
    foregroundModeFlag = 1;
  } 
  else //exit the foreground-only mode
  {
    char *message = "\nExiting foreground-only mode\n";
    write(STDOUT_FILENO, message, 30);
    foregroundModeFlag = 0; 
  }
  
  //writes prompt to the console
  char *prompt = ": "; 
  write(STDOUT_FILENO, prompt, 2); 
  fflush(stdout);
}


//free memory from a single char pointer 
//INPUT: char* file
//OUTPUT: nothing
void freeMemPointer(char* file)
{
    if (file != NULL)
    {
        free(file);
        file = NULL;
    }
    return;
}


//free memory from a double pointer char
//INPUT: char** file
//OUTPUT: nothing
void freeMem2xPointer(char**file)
{
    if (file != NULL)
    {
        free(file);
    }
    file = NULL;
    return;
}            
    </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">Small shell</p>
            <img class="codeExampleIcon" src="./images/cIcon.jpg">
            <br><br>
            <span class="codeTableInnerText">This program will create a small shell for the user to enter commands on,
              similar to a bash shell. It is built using C. <br><br>
              Most commands will be executed by exec() type functions, except for "cd", "status", and "exit", along with
              expanding every instance of "$$" to the current working PID number. <br><br>
              Other commands include sending input/commands to a background process, output and input redirection,
              signal processing, and other command variations, which can be found on the full GitHub repository.
            </span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/Portfolio/tree/main/C/Small%20Shell">Full Code</a></p>
          </td>
        </tr>
      </table>
    </div>

    <br>

    <!-- Flutter Wasteagram -->
    <div class="codeExamplesClassReveal" id="wasteagramReveal">
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
                <pre class="codeExampleInnerBox">
//Form Widget page:

import '../imports.dart';

class FormWidget extends StatefulWidget {
  final String imagePath;
  FormWidget({this.imagePath});
  @override
  _FormWidgetState createState() => _FormWidgetState(imagePath: imagePath);
}

class _FormWidgetState extends State<FormWidget> {
  LocationData locationData;
  final String imagePath;
  int itemCount;
  //Entry entry = Entry();

  _FormWidgetState({this.imagePath});

  // Function will set the locationData var
  retrieveLocation() async {
    var locationService = Location();
    locationData = await locationService.getLocation();
  }

  @override
  Widget build(BuildContext context) {
    final formKey = GlobalKey<FormState>();
    return Form(
        key: formKey,
        child: Column(children: <Widget>[
          promptForItems(context),
          sendDataToFirestore(formKey),
        ]));
  }

  //collects other data from user (date, time), adds them to our post
  //and sends it to the firestore for storage
  Container sendDataToFirestore(formKey) {
    return Container(
        decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(15.0),
            border: Border.all(color: Colors.grey, width: 4)),
        foregroundDecoration: BoxDecoration(
            borderRadius: BorderRadius.circular(15.0),
            border: Border.all(color: Colors.blueGrey, width: 7)),
        width: 100,
        height: 100,
        child: Semantics(
          label: "Submit button",
          hint: "Submit button",
          button: true,
          enabled: true,
          child: RaisedButton(
            key: Key('submitButton'),
            onPressed: () async {
              if (formKey.currentState.validate()) {
                formKey.currentState.save();
                // Format Date
                //OLD-> Timestamp date = DateFormat.yMd().format(DateTime.now());
                var date = DateTime.now();

                // Get location data (stores in longitude and latitude)
                await retrieveLocation();

                await Firestore.instance.collection('posts').add({
                  'date': date,
                  'itemCount': itemCount,
                  'latitude': locationData.latitude.toString(),
                  'longitude': locationData.longitude.toString(),
                  'url': imagePath
                });
                Navigator.pop(context);
              }
            },
            child: Icon(
              Icons.cloud_upload_outlined,
              size: 60,
            ),
          ),
        ));
  }

  //prompts user for number of items wasted. If not a number or below 1, displays error
  Padding promptForItems(BuildContext context) {
    //For getting the language:
    var language = Localizations.localeOf(context); //get phone's location
    return Padding(
      padding: const EdgeInsets.only(bottom: 30),
      child: Semantics(
        hint: 'Enter number of items wasted here',
        child: TextFormField(
          textAlign: TextAlign.center,
          keyboardType: TextInputType.number,
          decoration: InputDecoration(
              hintText: Translations(language).getQuantityFieldHint(language)),
          style: Styles.headline2,
          validator: (value) {
            if (!isNumAndPos(value)) {
              return 'Please enter a positive number';
            }
            return null;
          },
          onSaved: (value) {
            itemCount = int.parse(value);
          },
        ),
      ),
    );
  }

  //validator to make sure entered string is a positive number
  bool isNumAndPos(String string) {
    // Null or empty string is not a number
    if (string == null || string.isEmpty) {
      return false;
    }
    //parse a string to a number (will return null if not number)
    final number = num.tryParse(string);
    if (number == null) {
      return false;
    }
    //if value is a number, check to make sure it's greater than 0
    if (number <= 0) {
      return false;
    }
    return true;
  }
}
        </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">Wasteagram Mobile App</p>
            <img class="codeExampleIcon" src="./images/flutterIcon.png">
            <img class="codeExampleIcon" src="./images/dartIcon.png">
            <br><br>
            <span class="codeTableInnerText">Wasteagram, a mobile app that enables coffee shop employees to document
              daily food waste in the form of "posts" consisting of a photo, number of leftover items, the current date,
              and the location of the device when the post is created. The application also displays a list of all
              previous posts as well as a running total at the top.
              <br><br>
              This app was built using Flutter and Dart code.
            </span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/PORTFOLIO-Web-Development-HTML5-CSS-Node.js-JavaScript-C-Cpp-Rust-Assembly-Language/tree/main/Mobile%20Apps/Wasteagram">Full
                Code</a></p>
          </td>
        </tr>
      </table>
    </div>

    <br>

    <!-- ASM calculating composites-->
    <div class="codeExamplesClassReveal" id="ASMReveal">
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
            <pre class="codeExampleInnerBox">
TITLE Composites     (Project4.asm)
; Author: Patrick Stumbaugh

; Description: Calculate composite numbers using procedures and loops

INCLUDE Irvine32.inc

HLIMIT = +400
LLIMIT = +1

.data
EC1		BYTE "**EC1: Align the output columns.",0
EC2		BYTE "**EC2: Display more composites",0
greet	BYTE "Composite Numbers programmed by Pat Stumbaugh",0
intro	BYTE "Enter the number of composite numbers you would like to see.",0
intro2	BYTE "I'll accept orders for up to 400 composites.", 0
ask		BYTE "Enter the number of composites to display [1 .. 400]: ",0
error	BYTE "Out of range. Try again.",0
goodbye	BYTE "Results certified by Pat Stumbaugh. Goodbye.",0
extra	BYTE "Would you like to see another ten composite numbers?",0
entry	BYTE "Type 1 for yes, 0 for no: ",0
spaces	BYTE "    ",0
space	BYTE " ",0
user	DWORD ?
checkN	DWORD 0 ;0 will indicate true, 1 will indicate false (for user check)
number	DWORD 4 ;starting at the first composite positive number
ten		DWORD 10
divisor	DWORD 1

.code
main PROC

;displays intro and greeting
  call	introduction

;displays extra credit
  mov		edx, OFFSET EC1
  call	WriteString
  call	CrLf
  mov		edx, OFFSET EC2
  call	WriteString
  call	CrLf
  call	CrLf

;gets user data / checks to see if it's in range
;(tried using stack for this call)
  push	OFFSET checkN
  push	OFFSET user
  call	getUserData

;displays user amount of composite numbers
  call	showComposites

;asks if user wants to see more composites
  call	ExtraCredit2

;displays goodbye message
  call	farewell

  exit	; exit to operating system
main ENDP


;-----------------------PROCEDURES-----------------------------


;displays the intro and greeting statement
;receive: nothing
;registers changed: edx, ebp
introduction PROC
  push	ebp
  mov		ebp, esp


  mov		edx, OFFSET greet
  call	WriteString
  call	CrLf
  call	CrLf


  mov		edx, OFFSET intro
  call	WriteString
  call	CrLf
  mov		edx, OFFSET intro2
  call	WriteString
  call	CrLf
  call	CrLf


  pop		ebp
  ret
introduction ENDP


;----------------------------------------------------------------------------
;prompts and gets user's number (stores in "user" variable)
;receives: offset user (user's number address), offset checkN
;registers changed: eax, ebx, edx, ebp
getUserData PROC
  push	ebp
  mov		ebp, esp


getUserNum:
  ;dispaly call message
  mov		eax, [ebp+12]			;checkN
  mov		ebx, 0					;reset checkN to 0
  mov		[eax], ebx
  mov		edx, OFFSET ask
  call	WriteString


  ;read the integer from the user, store in ebx
  mov		ebx, [ebp+8]			;user
  call	ReadInt
  mov		[ebx],eax


  ;push the user number and the checkN, call checkRange
  push	[ebp+12]				;checkN
  push	[ebp+8]					;user
  call	validate				;call sub-procedure


  ;see if checkN variable is still 0 (indicating user number
  ;is within range. If true, continue on, if false, start over from top
  mov		ebx, [ebp+12]
  mov		eax, [ebx]
  mov		ebx, 0
  cmp		eax, ebx
  jnz		getUserNum


  pop		ebp
  ret		8
getUserData ENDP


;----------------------------------------------------------------------------
;checks the user's number to our specified range
;receives: offset user, offset checkN
;registers affected: eax, ebx, ebp
validate PROC
  push	ebp
  mov		ebp, esp


  ;check upper limit
  mov		eax, [ebp+8]			;move address of user into eax
  mov		eax, [eax]				;move value of user into eax
  mov		ebx, HLIMIT		
  cmp		eax, ebx
  jg		outOfRange				;jump to error if greater than upper limit


  ;check lower limit
  mov		eax, [ebp+8]			;move address of user into eax
  mov		eax, [eax]				;move value of user into eax
  mov		ebx, LLIMIT		
  cmp		eax, ebx
  jge		continue				;jump to continue if above lower limit


  ;display out of range message, change checkN to 1 (indicating false)
  ;I'm using 1 as a fault and 0 as a true message in the main
outOfRange:
  mov		edx, OFFSET error
  call	WriteString
  call	CrLf
  mov		eax, [ebp+12]
  mov		ebx, 1
  mov		[eax], ebx


continue:
  pop		ebp
  ret		8
validate ENDP


;----------------------------------------------------------------------------
;displays all the composite numbers up through the user's number
;makes a new line every ten numbers displayed
;received: nothing
;registers affected: ebx, ecx, ebp
showComposites PROC
  push	ebp
  mov		ebp, esp
  call	CrLf


  mov		ten, 10					;numbers per line counter
  mov		ecx, user				;user number used for loop


L1:
  pushad							;save registers to stack
  call isComposite				;call sub-procedure
  popad							;bring back registers from stack


;subtracts 1 from our ten counter. If 0, make a new line, if not, loop back
  sub		ten, 1
  mov		ebx, ten
  cmp		ebx, 0
  jz		resetTen
  loop	L1						;**uses LOOP to decrement ecx


;resets the line counter back to ten
;if the loop counter (ecx) is at 0, then jump to finish
resetTen:
  mov		ten, 10
  call	CrLf
  mov		ebx, ecx
  cmp		ebx, 0
  jz		continue
  loop	L1						;**uses LOOP to decrement ecx


continue:
  pop		ebp
  ret		
showComposites ENDP

;----------------------------------------------------------------------------
;finds the next composite number, displays it
;receives: nothing
;registers affected: eax, ebx, edx, ebp
isComposite PROC
  push	ebp
  mov		ebp, esp


;sets up starting variables
  mov		eax, number				;number will be last number tried
  mov		divisor, 1				;sets our starting divisor to 1
  mov		ebx, 0					;used to count number of divisions
  jmp		L1


;resets divisor, ebx counter and increments number
reset:
  inc		number
  mov		eax, number
  mov		divisor, 1
  mov		ebx, 0


;compares our current number to the divisor
L1:
  mov		edx, 0
  mov		eax, number
  cdq
  idiv	divisor
;if no remainder (found a clean division), jump to foundDivision
;otherwise increment divisor and try again
;if divisor is equal to the number, jump to reset loop
  cmp		edx, 0
  jz		foundDivision
  inc		divisor
  mov		eax, number
  cmp		eax, divisor
  je		reset
  jmp		L1


foundDivision:
  inc		ebx
  cmp		ebx, 2					;if divisable by 2+ #'s (it's composite)
  je		foundComposite
  inc		divisor
  mov		eax, number
  cmp		divisor, eax
  je		reset
  jmp		L1


;composite number found, display it, add one (for next time called) and return
foundComposite:
  mov		eax, number
  cmp		eax, 100
  jge		more1
  mov		edx, OFFSET space
  call	WriteString
more1:
  mov		eax, number
  cmp		eax, 10
  jge		more
  mov		edx, OFFSET space
  call	WriteString
more:
  mov		edx, OFFSET spaces
  call	WriteString
  mov		eax, number
  call	WriteDec
  inc		number
  jmp		continue


continue:
  pop		ebp
  ret		
isComposite ENDP


;----------------------------------------------------------------------------
;Displays goodbye message
;receives: nothing
;registers affected: edx, ebp
farewell PROC
  push	ebp
  mov		ebp, esp


  call	CrLf
  mov		edx, OFFSET goodbye
  call	WriteString
  call	CrLf


  pop		ebp
  ret
farewell ENDP


;----------------------------------------------------------------------------
;Displays another line of composites (extra credit 2)
;receives: nothing
;registers affected: ebp, edx
ExtraCredit2 PROC
  push	ebp
  mov		ebp, esp


;ask if user wants another ten numbers
L1:
  call	CrLf
  mov		edx, OFFSET extra
  call	WriteString
  call	CrLf
  mov		edx, OFFSET entry
  call	WriteString
  call	ReadInt
  cmp		eax, 1
  jne		continue


  mov		user, 10				;adds ten to our previous user number
  call showComposites				;displays another ten composites
  jmp L1


continue:
  pop		ebp
  ret
ExtraCredit2 ENDP

END main    
    </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">Calculate Composite Numbers</p>
            <img class="codeExampleIcon" src="./images/asmIcon.png">
            <br><br>
            <span class="codeTableInnerText">This program will calculate and display all composite numbers up through a
              user inputted max number. It is built using Assembly Language. <br><br>
              The program is designed as a way to practice calling procedures and sub-procedures while pushing and
              popping variables to and from the stack memory. <br><br>
              It also is a practice in using different types of registers, including the instruction pointer while in a
              called procedure. It also has loops, jumps, compares and other methods.
            </span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/Portfolio/tree/main/Assembly%20Language/Calculating%20Composites">Full
                Code</a></p>
          </td>
        </tr>
      </table>
    </div>

    <br>

    <!-- Map Reduce -->
    <div class="codeExamplesClassReveal" id="mapReveal">
      <table class="codeTableContainer">
        <tr class="codeTableText">
          <td class="codeExampleOuterBox">
            <code>
            <pre class="codeExampleInnerBox">
//Patrick Stumbaugh
/*compile by using command: rustc main.rs 
Then, execute using command: ./main num_partitions num_elements
Where num_partitions and num_elements are your choice
(ie): ./main 6 153

use std::env; // to get arugments passed to the program
use std::thread; // for threads

//A single threaded map-reduce program
fn main() {

    // Use std::env to get arguments passed to the program
    let args: Vec&ltString> = env::args().collect();
    if args.len() != 3 {
        println!("ERROR: Usage {} num_partitions num_elements", args[0]);
        return;
    }
    //number of partitions to create:
    let num_partitions : usize = args[1].parse().unwrap();
    //number of elements total being used:
    let num_elements : usize = args[2].parse().unwrap();
    
    //if less than one partition, error:
    if num_partitions &lt 1{
      println!("ERROR: num_partitions must be at least 1");
        return;
    }
    
    //if there are more partitions then there are elements, error:
    if num_elements &lt num_partitions{
        println!("ERROR: num_elements cannot be smaller than num_partitions");
        return;
    }

    // Generate data to go in our partitions (saved as a vector)
    let v = generate_data(num_elements);

    // PARTITION STEP: partition the data into 2 partitions
    let xs = partition_data_in_two(&v);

    // Print info about the partitions
    print_partition_info(&xs);

    let mut intermediate_sums : Vec&ltusize> = Vec::new();

    //following code is an example of running two threads concurrently, 
    //manually coded to do so. 
    let xs_clone = xs.clone(); //using a clone for the first handle
    let part1 = thread::spawn(move ||map_data(&xs_clone[0]));
    let part2 = thread::spawn(move ||map_data(&xs[1]));
    
    //join/unwrap our threads
    let new1 = part1.join().unwrap();
    let new2 = part2.join().unwrap();
    
    //push our threads (already joined) to the intermediate_sums
    intermediate_sums.push(new1);
    intermediate_sums.push(new2);

    // Print the vector with the intermediate sums
    println!("Intermediate sums = {:?}", intermediate_sums);

    // REDUCE STEP: Process the intermediate result to produce the final result
    let sum = reduce_data(&intermediate_sums);
    println!("Sum = {}", sum);


    //following is an example of running an unknown amount of threads concurrently

    //variables:
    let mut intermediate_sums2 : Vec&ltusize> = Vec::new();//create a new vector to hold intermediate sums
    let mut part_counter = 0;//number of partitions we'll have to make individual threads for (used as a counter)
    let mut handles = Vec::new(); //create a new vector for handles (to hold our threads)
    
    //Calls partition_data to partition the data into equal partitions
    let partitioned_data = partition_data(num_partitions, &v);
    
    //Calls print_partition_info to print info on the partitions that have been created
    print_partition_info(&partitioned_data);

    //Creates one thread per partition and uses each thread to concurrently process one partition
    while part_counter != num_partitions {
        let part_clone = partitioned_data.clone(); //clone variable
        let new_part1 = thread::spawn(move ||map_data(&part_clone[part_counter])); //spawn a new thread
        handles.push(new_part1); //save new thread by pushing to handles vector
        part_counter = part_counter + 1;//increment counter
    }
    
    //Collects the intermediate sums from all the threads
    for child in handles {
        let adding_item = child.join().unwrap(); //join the return value for each item in handles vector of threads
        intermediate_sums2.push(adding_item); //push to the intermediate_sums2
    }
    
    //Prints information about the intermediate sums
    println!("Intermediate sums = {:?}", intermediate_sums2);


    //Calls reduce_data to process the intermediate sums
    let sum2 = reduce_data(&intermediate_sums2);
    
    //Prints the final sum computed by reduce_data
    println!("Sum = {}", sum2);
    
}

//*******FUNCTIONS**********

//Print the number of partitions and the size of each partition
fn print_partition_info(vs: &Vec&ltVec&ltusize>>){
    println!("Number of partitions = {}", vs.len());
    for i in 0..vs.len(){
        println!("\tsize of partition {} = {}", i, vs[i].len());
    }
}


//Create a vector with integers from 0 to num_elements -1
fn generate_data(num_elements: usize) -> Vec&ltusize>{
    let mut v : Vec&ltusize> = Vec::new();
    for i in 0..num_elements {
        v.push(i);
    }
    return v;
}


//Partition the data in the vector v into 2 vectors

fn partition_data_in_two(v: &Vec&ltusize>) -> Vec&ltVec&ltusize>>{
    let partition_size = v.len() / 2;
    // Create a vector that will contain vectors of integers
    let mut xs: Vec&ltVec&ltusize>> = Vec::new();


    // Create the first vector of integers
    let mut x1 : Vec&ltusize> = Vec::new();
    // Add the first half of the integers in the input vector to x1
    for i in 0..partition_size{
        x1.push(v[i]);
    }
    // Add x1 to the vector that will be returned by this function
    xs.push(x1);


    // Create the second vector of integers
    let mut x2 : Vec&ltusize> = Vec::new();
    // Add the second half of the integers in the input vector to x2
    for i in partition_size..v.len(){
        x2.push(v[i]);
    }
    // Add x2 to the vector that will be returned by this function
    xs.push(x2);
    // Return the result vector
    xs
}


//Sum up the all the integers in the given vector
fn map_data(v: &Vec&ltusize>) -> usize{
    let mut sum = 0;
    for i in v{
        sum += i;
    }
    sum
}


//Sum up the all the integers in the given vector
fn reduce_data(v: &Vec&ltusize>) -> usize{
    let mut sum = 0;
    for i in v{
        sum += i;
    }
    sum
}

/* Partitions the data into a number of partitions such that
* - the returned partitions contain all elements that are in the input vector
* - if num_elements is a multiple of num_partitions, then all partitions must have equal number of elements
* - if num_elements is not a multiple of num_partitions, some partitions can have one more element than other partitions
*/
fn partition_data(num_partitions: usize, v: &Vec&ltusize>) -> Vec&ltVec&ltusize>>{

    //size of each partition
    let part_size = v.len()/num_partitions;
    let mut leftovers = v.len()%num_partitions;


    //Vector of vectors of integers
    let mut array_vector: Vec&ltVec&ltusize>> = Vec::new(); //create vector holding an array of vectors of integers
    let mut counter = 0; //holding item for data in v
    let mut looper = 0; //holding item for looping through number of partitions
    
    while looper != num_partitions {
        //create a temp vector to hold items
        let mut adding_vector : Vec&ltusize> = Vec::new();
        
        //loop through the param data, adding to our temp vector
        for _i in 0..part_size {
            adding_vector.push(v[counter]);
            counter = counter + 1; //increment counter
        }
        
        //add any leftovers if given
        if leftovers != 0 {
            adding_vector.push(v[counter]);
            counter = counter + 1; //increment counter
            leftovers = leftovers - 1; //decrement leftovers
        }
        
        //push our temp vector to the main vector 
        array_vector.push(adding_vector);
        
        //increment the looper
        looper = looper + 1;
    }
    
    return array_vector;
}            
    </pre></code>
          </td>
          <td class="codeTableInner"><br>
            <p class="codeTableDescriptionTitle">Map Reduce</p>
            <img class="codeExampleIcon" src="./images/rustIcon.jpg">
            <br><br>
            <span class="codeTableInnerText">This program is an example of both a single-threaded and multi-threaded
              Rust program, with all threads running concurrently. <br><br>
              The program is split into two sections. The first section takes the data and splits it in two, then runs
              the algorithm and manually splits the results into two partitions, running each as a thread concurrently.
              <br><br>
              The second part of the program takes the same data, but splits it into the user specified number of
              partitions. Then, these partitions will create just as many threads, running concurrently.
            </span>
            <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink"
                href="https://github.com/pstumbaugh/Portfolio/tree/main/Rust/MapReduce">Full Code</a></p>
          </td>
        </tr>
      </table>
    </div>

    <br>

  </div>
  <!-- base coding template
    <table class="codeTableContainer">
      <tr class="codeTableText">
        <td class="codeExampleOuterBox">
          <code>
            <pre class="codeExampleInnerBox">
Code here
    </pre></code>
        </td>
        <td class="codeTableInner"><br>
          <p class="codeTableDescriptionTitle">Portfolio website</p>
          <img class="codeExampleIcon" src="./images/html5Icon.jpeg">
          <br><br>
          <span class="codeTableInnerText">text here
          </span>
          <p class="codeTableInnerTextBottom"><a target="_blank" class="emptyColorLink" href="">Full Code</a></p>
        </td>
      </tr>
    </table>

    <br><br>
  -->


  <a target="_blank" href="https://github.com/pstumbaugh/Portfolio" id="githubPortfolioLink">GitHub Portfolio</a>


  <br>

  <br><br>

  <!-- footer links -->
  <div class="footerLinks">
    <a class="footerLink" href="tel:6508683189"><img class="footerIcon" src="./images/phoneIcon.png">
      <p class="footerText">(650) 868-3189</p>
    </a>
    <a class="footerLink" href="mailto:stumbaugh.patrick@gmail.com"><img class="footerIcon"
        src="./images/emailIcon.png">
      <p class="footerText">stumbaugh.patrick@gmail.com</p>
    </a>

    <br>
    <a target="_blank" href="https://github.com/pstumbaugh/Portfolio">
      <img class="buttonsImage" src="./images/githublogo2.png" alt="Github"></a>
    &nbsp;&nbsp;&nbsp;
    <a target="_blank" href="https://www.linkedin.com/in/patrick-stumbaugh-7625662a/">
      <img class="buttonsImage" src="./images/linkedinlogo2.png" alt="LinkedIn"></a>


    <!-- footer image-->
    <div class="drippingYellowContainerBottom">
      <img class="drippingYellowBottom" src="./images/upsideDownDrippingYellowEditedSIDES.png">
    </div>

    <div class="drippingYellowContainerCenter">
      <img class="drippingYellowCenter" src="./images/upsideDownDrippingYellowEditedSIDES.png">
    </div>
    <script src="home.js"></script>
</body>

</html>